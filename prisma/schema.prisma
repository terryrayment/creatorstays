generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// Auth Models (NextAuth compatible)
// ============================================================================

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ============================================================================
// Core User Model
// ============================================================================

enum UserRole {
  HOST
  CREATOR
  ADMIN
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  emailVerified DateTime?
  name          String?
  image         String?
  role          UserRole?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts       Account[]
  sessions       Session[]
  hostProfile    HostProfile?
  creatorProfile CreatorProfile?
  paymentAccount PaymentAccount?
}

// ============================================================================
// Profile Models
// ============================================================================

enum VerificationStatus {
  PENDING
  VERIFIED
  REJECTED
}

model HostProfile {
  id                 String             @id @default(cuid())
  userId             String             @unique
  displayName        String
  companyName        String?
  bio                String?            @db.Text
  location           String?
  website            String?
  verificationStatus VerificationStatus @default(PENDING)
  hasCompletedSetup  Boolean            @default(false)
  hasPaidListingFee  Boolean            @default(false)
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt

  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  properties Property[]
  offers     Offer[]
  deals      Deal[]     @relation("HostDeals")
}

enum PreferredDealType {
  PERCENT_COMMISSION
  FLAT_FEE
  POST_FOR_STAY
  HYBRID
}

enum PreferredRateType {
  PER_BOOKING
  PER_NIGHT
  PER_POST
  NEGOTIABLE
}

model CreatorProfile {
  id                  String              @id @default(cuid())
  userId              String              @unique
  displayName         String
  bio                 String?             @db.Text
  niches              String[]
  instagramHandle     String?
  tiktokHandle        String?
  youtubeHandle       String?
  audienceSize        Int?
  mediaKitUrl         String?
  portfolioUrl        String?
  preferredDealTypes  PreferredDealType[]
  preferredRateType   PreferredRateType?
  preferredRateValue  Float?
  hasCompletedSetup   Boolean             @default(false)
  hasAcceptedTerms    Boolean             @default(false)
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt

  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  deals           Deal[]           @relation("CreatorDeals")
  trackingClicks  TrackingClick[]
}

// ============================================================================
// Property & Offer Models
// ============================================================================

enum PropertyStatus {
  DRAFT
  PENDING_REVIEW
  ACTIVE
  PAUSED
  ARCHIVED
}

model Property {
  id           String         @id @default(cuid())
  hostId       String
  title        String
  description  String?        @db.Text
  city         String
  state        String?
  country      String
  airbnbUrl    String
  vrboUrl      String?
  directUrl    String?
  heroImageUrl String?
  gallery      String[]
  maxGuests    Int?
  bedrooms     Int?
  bathrooms    Float?
  amenities    String[]
  status       PropertyStatus @default(DRAFT)
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt

  host           HostProfile     @relation(fields: [hostId], references: [id], onDelete: Cascade)
  offers         Offer[]
  trackingClicks TrackingClick[]

  @@index([hostId])
  @@index([status])
  @@index([city, country])
}

enum OfferType {
  PERCENT
  FLAT
  POST_FOR_STAY
  HYBRID
}

enum OfferStatus {
  DRAFT
  ACTIVE
  PAUSED
  EXPIRED
  ARCHIVED
}

model Offer {
  id                    String      @id @default(cuid())
  hostId                String
  propertyId            String
  title                 String
  description           String?     @db.Text
  offerType             OfferType
  currency              String      @default("USD")
  percentRate           Float?      // e.g., 0.10 for 10%
  flatAmount            Float?      // e.g., 50.00
  freeNights            Int?        // For POST_FOR_STAY
  minBookingValue       Float?      // Minimum booking value to qualify
  maxPayout             Float?      // Cap on payout per booking
  attributionWindowDays Int         @default(30)
  cookieRequired        Boolean     @default(true)
  requiresApproval      Boolean     @default(true)
  status                OfferStatus @default(DRAFT)
  startsAt              DateTime?
  endsAt                DateTime?
  createdAt             DateTime    @default(now())
  updatedAt             DateTime    @updatedAt

  host           HostProfile     @relation(fields: [hostId], references: [id], onDelete: Cascade)
  property       Property        @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  deals          Deal[]
  trackingClicks TrackingClick[]

  @@index([hostId])
  @@index([propertyId])
  @@index([status])
}

// ============================================================================
// Deal & Tracking Models
// ============================================================================

enum DealStatus {
  PROPOSED    // Creator applied or host proposed
  PENDING     // Waiting for approval
  ACTIVE      // Deal is live, tracking enabled
  SUBMITTED   // Booking claim submitted
  APPROVED    // Booking approved, pending payout
  REJECTED    // Booking claim rejected
  DISPUTED    // Under dispute review
  PAID        // Payout completed
  CANCELLED   // Deal cancelled
  EXPIRED     // Deal expired without activity
}

model Deal {
  id            String     @id @default(cuid())
  offerId       String
  hostId        String
  creatorId     String
  status        DealStatus @default(PROPOSED)
  proposedBy    UserRole   // WHO proposed the deal
  startAt       DateTime?
  endAt         DateTime?
  agreedPercent Float?     // Final agreed percentage
  agreedFlat    Float?     // Final agreed flat amount
  notes         String?    @db.Text
  
  // FTC Disclosure
  hasAgreedToDisclose Boolean @default(false)
  
  // Tracking link
  trackingToken String     @unique @default(cuid())
  
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  offer          Offer               @relation(fields: [offerId], references: [id], onDelete: Cascade)
  host           HostProfile         @relation("HostDeals", fields: [hostId], references: [id], onDelete: Cascade)
  creator        CreatorProfile      @relation("CreatorDeals", fields: [creatorId], references: [id], onDelete: Cascade)
  trackingClicks TrackingClick[]
  bookingClaims  BookingClaim[]
  ledgerEntries  LedgerEntry[]

  @@index([offerId])
  @@index([hostId])
  @@index([creatorId])
  @@index([status])
  @@index([trackingToken])
}

model TrackingClick {
  id          String   @id @default(cuid())
  dealId      String?
  offerId     String
  creatorId   String
  propertyId  String
  clickToken  String   @unique
  ipHash      String?  // Hashed for privacy
  userAgent   String?
  referer     String?
  landingUrl  String
  createdAt   DateTime @default(now())

  deal               Deal?               @relation(fields: [dealId], references: [id], onDelete: SetNull)
  offer              Offer               @relation(fields: [offerId], references: [id], onDelete: Cascade)
  creator            CreatorProfile      @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  property           Property            @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  visitorAttribution VisitorAttribution?

  @@index([dealId])
  @@index([offerId])
  @@index([creatorId])
  @@index([clickToken])
  @@index([createdAt])
}

enum ConsentStatus {
  UNKNOWN
  ACCEPTED
  DECLINED
}

model VisitorAttribution {
  id            String        @id @default(cuid())
  clickId       String        @unique
  cookieId      String        // First-party cookie ID
  firstSeenAt   DateTime      @default(now())
  lastSeenAt    DateTime      @default(now())
  consentStatus ConsentStatus @default(UNKNOWN)
  visitCount    Int           @default(1)

  click TrackingClick @relation(fields: [clickId], references: [id], onDelete: Cascade)

  @@index([cookieId])
  @@index([lastSeenAt])
}

// ============================================================================
// Booking Claims & Payouts
// ============================================================================

enum BookingClaimStatus {
  SUBMITTED
  NEEDS_INFO
  UNDER_REVIEW
  APPROVED
  REJECTED
  DISPUTED
}

enum AttributionConfidence {
  HIGH   // Cookie match, recent activity
  MEDIUM // Click exists but stale
  LOW    // No click found
  NONE   // No attribution possible
}

model BookingClaim {
  id              String                @id @default(cuid())
  dealId          String
  submittedByHost Boolean               @default(true)
  guestFirstName  String?
  guestEmail      String?               // Optional, for verification
  checkInDate     DateTime
  checkOutDate    DateTime
  bookingAmount   Float?
  currency        String                @default("USD")
  proofUrl        String?               // Screenshot or invoice URL
  proofNotes      String?               @db.Text
  status          BookingClaimStatus    @default(SUBMITTED)
  
  // Attribution
  attributedClickId   String?
  attributionConfidence AttributionConfidence @default(NONE)
  attributionNotes    String?           @db.Text
  
  // Review
  reviewedBy      String?
  reviewedAt      DateTime?
  rejectionReason String?               @db.Text
  
  createdAt       DateTime              @default(now())
  updatedAt       DateTime              @updatedAt

  deal Deal @relation(fields: [dealId], references: [id], onDelete: Cascade)

  @@index([dealId])
  @@index([status])
  @@index([checkInDate])
}

// ============================================================================
// Payments & Ledger
// ============================================================================

model PaymentAccount {
  id                     String   @id @default(cuid())
  userId                 String   @unique
  stripeCustomerId       String?  @unique
  stripeConnectAccountId String?  @unique
  chargesEnabled         Boolean  @default(false)
  payoutsEnabled         Boolean  @default(false)
  detailsSubmitted       Boolean  @default(false)
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([stripeCustomerId])
  @@index([stripeConnectAccountId])
}

enum LedgerEntryType {
  HOST_LISTING_FEE     // $199 one-time fee
  HOST_CAMPAIGN_FUND   // Host deposits funds for payouts
  HOST_CHARGE          // Charge for a booking payout
  PLATFORM_FEE_HOST    // 15% from host side
  PLATFORM_FEE_CREATOR // 15% from creator side
  CREATOR_PAYOUT       // Payout to creator
  REFUND               // Refund to host
  ADJUSTMENT           // Manual adjustment
}

enum LedgerEntryStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

model LedgerEntry {
  id          String            @id @default(cuid())
  dealId      String?
  userId      String?           // Associated user
  type        LedgerEntryType
  status      LedgerEntryStatus @default(PENDING)
  amount      Float             // Always positive, direction implied by type
  currency    String            @default("USD")
  description String?
  stripeRef   String?           // Stripe PaymentIntent, Transfer, etc.
  metadata    Json?             // Additional details
  createdAt   DateTime          @default(now())

  deal Deal? @relation(fields: [dealId], references: [id], onDelete: SetNull)

  @@index([dealId])
  @@index([userId])
  @@index([type])
  @@index([createdAt])
}

// ============================================================================
// Audit & System
// ============================================================================

model AuditLog {
  id        String   @id @default(cuid())
  userId    String?
  action    String
  entity    String
  entityId  String?
  details   Json?
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([entity, entityId])
  @@index([createdAt])
}
