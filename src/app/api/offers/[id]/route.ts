import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { sendEmail, offerAcceptedEmail } from '@/lib/email'
import { nanoid } from 'nanoid'

export const dynamic = 'force-dynamic'

// Generate agreement text
function generateAgreementText(data: {
  hostName: string
  creatorName: string
  propertyTitle: string
  dealType: string
  cashCents: number
  stayNights: number | null
  deliverables: string[]
}): string {
  const { hostName, creatorName, propertyTitle, dealType, cashCents, stayNights, deliverables } = data
  
  const cashAmount = (cashCents / 100).toFixed(2)
  const deliverablesList = deliverables.map((d, i) => `  ${i + 1}. ${d}`).join('\n')
  
  return `
CREATORSTAYS COLLABORATION AGREEMENT

This Agreement is entered into between:

HOST: ${hostName}
CREATOR: ${creatorName}

PROPERTY: ${propertyTitle}

DEAL TYPE: ${dealType === 'post-for-stay' ? 'Post-for-Stay' : dealType === 'flat-with-bonus' ? 'Flat Fee + Performance Bonus' : 'Flat Fee'}

COMPENSATION:
${cashCents > 0 ? `- Cash Payment: $${cashAmount}` : ''}
${stayNights ? `- Complimentary Stay: ${stayNights} nights` : ''}

DELIVERABLES:
${deliverablesList}

TERMS:
1. Creator agrees to produce and publish the deliverables listed above.
2. All content must feature the Property and include the provided tracking link.
3. Content must comply with FTC disclosure requirements (#ad or #sponsored).
4. Creator retains ownership of content but grants Host perpetual license to use.
5. Host agrees to provide compensation as outlined above upon content approval.
6. Platform fee of 15% applies to both parties.

CONTENT DEADLINE: 30 days from agreement execution.

By signing below, both parties agree to these terms.

---
Generated by CreatorStays on ${new Date().toLocaleDateString()}
`.trim()
}

// PATCH /api/offers/[id] - Respond to offer (accept/counter/decline)
export async function PATCH(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { action, counterCashCents, counterMessage } = body

    if (!['accept', 'counter', 'decline'].includes(action)) {
      return NextResponse.json({ error: 'Invalid action' }, { status: 400 })
    }

    // Get creator profile
    const creatorProfile = await prisma.creatorProfile.findUnique({
      where: { userId: session.user.id },
    })

    if (!creatorProfile) {
      return NextResponse.json({ error: 'Creator profile not found' }, { status: 404 })
    }

    // Get the offer
    const offer = await prisma.offer.findUnique({
      where: { id: params.id },
      include: {
        hostProfile: {
          include: { user: true },
        },
      },
    })

    if (!offer) {
      return NextResponse.json({ error: 'Offer not found' }, { status: 404 })
    }

    // Verify this offer is for the current creator
    if (offer.creatorProfileId !== creatorProfile.id) {
      return NextResponse.json({ error: 'This offer is not for you' }, { status: 403 })
    }

    // Verify offer is still pending
    if (offer.status !== 'pending') {
      return NextResponse.json({ error: 'This offer has already been responded to' }, { status: 400 })
    }

    // Handle DECLINE
    if (action === 'decline') {
      await prisma.offer.update({
        where: { id: params.id },
        data: {
          status: 'declined',
          respondedAt: new Date(),
        },
      })

      return NextResponse.json({
        success: true,
        message: 'Offer declined.',
      })
    }

    // Handle COUNTER
    if (action === 'counter') {
      if (!counterCashCents || counterCashCents <= 0) {
        return NextResponse.json({ error: 'Counter amount required' }, { status: 400 })
      }

      await prisma.offer.update({
        where: { id: params.id },
        data: {
          status: 'countered',
          counterCashCents,
          counterMessage,
          respondedAt: new Date(),
        },
      })

      // TODO: Send email to host about counter offer

      return NextResponse.json({
        success: true,
        message: 'Counter offer sent to host.',
      })
    }

    // Handle ACCEPT
    if (action === 'accept') {
      // Get property for the collaboration
      const property = await prisma.property.findFirst({
        where: { hostProfileId: offer.hostProfileId },
      })

      if (!property) {
        return NextResponse.json({ error: 'Host has no property configured' }, { status: 400 })
      }

      // Generate tracking token
      const affiliateToken = nanoid(12)

      // Create collaboration
      const collaboration = await prisma.collaboration.create({
        data: {
          hostId: offer.hostProfileId,
          creatorId: creatorProfile.id,
          propertyId: property.id,
          offerId: offer.id,
          status: 'pending-agreement',
          affiliateToken,
          contentDeadline: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days
        },
      })

      // Generate agreement text
      const agreementText = generateAgreementText({
        hostName: offer.hostProfile.displayName,
        creatorName: creatorProfile.displayName,
        propertyTitle: property.title || 'Property',
        dealType: offer.offerType,
        cashCents: offer.cashCents,
        stayNights: offer.stayNights,
        deliverables: offer.deliverables,
      })

      // Create agreement
      await prisma.collaborationAgreement.create({
        data: {
          collaborationId: collaboration.id,
          version: '1.0',
          agreementText,
          dealType: offer.offerType,
          cashAmount: offer.cashCents,
          stayIncluded: !!offer.stayNights,
          stayNights: offer.stayNights,
          deliverables: offer.deliverables,
          contentDeadline: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
        },
      })

      // Update offer status
      await prisma.offer.update({
        where: { id: params.id },
        data: {
          status: 'accepted',
          respondedAt: new Date(),
        },
      })

      // Send email to host
      const hostEmail = offer.hostProfile.user?.email || offer.hostProfile.contactEmail
      if (hostEmail) {
        const emailData = offerAcceptedEmail({
          hostName: offer.hostProfile.displayName,
          creatorName: creatorProfile.displayName,
          creatorHandle: creatorProfile.handle,
          propertyTitle: property.title,
          collaborationId: collaboration.id,
        })

        sendEmail({
          to: hostEmail,
          ...emailData,
        }).catch(err => console.error('[Offer Accept] Email error:', err))
      }

      return NextResponse.json({
        success: true,
        message: 'Offer accepted! Please sign the agreement to activate.',
        collaboration: {
          id: collaboration.id,
          affiliateToken,
        },
      })
    }

    return NextResponse.json({ error: 'Invalid action' }, { status: 400 })
  } catch (error) {
    console.error('[Offer Response API] Error:', error)
    return NextResponse.json({ error: 'Failed to respond to offer' }, { status: 500 })
  }
}
