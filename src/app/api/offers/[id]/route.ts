import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { sendEmail, offerAcceptedEmail, offerCounteredEmail, offerDeclinedEmail } from '@/lib/email'
import { nanoid } from 'nanoid'
import { recordOfferStatusChange } from '@/lib/offer-validation'
import { logOfferEvent, AUDIT_ACTIONS } from '@/lib/audit'
import { logOfferResponded } from '@/lib/analytics'
import { markFirstOfferResponded } from '@/lib/trust'

export const dynamic = 'force-dynamic'

// Generate agreement text
function generateAgreementText(data: {
  hostName: string
  creatorName: string
  propertyTitle: string
  dealType: string
  cashCents: number
  stayNights: number | null
  deliverables: string[]
}): string {
  const { hostName, creatorName, propertyTitle, dealType, cashCents, stayNights, deliverables } = data
  
  const cashAmount = (cashCents / 100).toFixed(2)
  const deliverablesList = deliverables.map((d, i) => `  ${i + 1}. ${d}`).join('\n')
  
  const isPostForStay = dealType === 'post-for-stay'
  
  const compensationSection = isPostForStay
    ? `- Complimentary Stay: ${stayNights} nights
- Platform Fee: $99 (charged to Host)`
    : `${cashCents > 0 ? `- Cash Payment: $${cashAmount}` : ''}
${stayNights ? `- Complimentary Stay: ${stayNights} nights` : ''}`

  const stayCoordinationSection = isPostForStay || stayNights
    ? `

STAY COORDINATION:
Host and Creator are responsible for coordinating stay dates directly. CreatorStays 
facilitates the collaboration but does not manage property calendars or bookings. 
The Host will arrange the complimentary stay through their preferred booking method 
(Airbnb, direct booking, etc.) once dates are mutually agreed upon.`
    : ''

  const feeSection = isPostForStay
    ? '6. Platform fee of $99 applies to this Post-for-Stay collaboration (charged to Host).'
    : '6. Platform fee of 15% applies to both parties.'
  
  return `
CREATORSTAYS COLLABORATION AGREEMENT

This Agreement is entered into between:

HOST: ${hostName}
CREATOR: ${creatorName}

PROPERTY: ${propertyTitle}

DEAL TYPE: ${dealType === 'post-for-stay' ? 'Post-for-Stay' : dealType === 'flat-with-bonus' ? 'Flat Fee + Performance Bonus' : 'Flat Fee'}

COMPENSATION:
${compensationSection}

DELIVERABLES:
${deliverablesList}
${stayCoordinationSection}

TERMS:
1. Creator agrees to produce and publish the deliverables listed above.
2. All content must feature the Property and include the provided tracking link.
3. Content must comply with FTC disclosure requirements (#ad or #sponsored).
4. Creator retains ownership of content but grants Host perpetual license to use.
5. Host agrees to provide compensation as outlined above upon content approval.
${feeSection}

CONTENT DEADLINE: 30 days from agreement execution.

By signing below, both parties agree to these terms.

---
Generated by CreatorStays on ${new Date().toLocaleDateString()}
`.trim()
}

// PATCH /api/offers/[id] - Respond to offer (accept/counter/decline)
export async function PATCH(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { action, counterCashCents, counterMessage } = body

    if (!['accept', 'counter', 'decline'].includes(action)) {
      return NextResponse.json({ error: 'Invalid action' }, { status: 400 })
    }

    // Get creator profile
    const creatorProfile = await prisma.creatorProfile.findUnique({
      where: { userId: session.user.id },
      include: { user: true },
    })

    if (!creatorProfile) {
      return NextResponse.json({ error: 'Creator profile not found' }, { status: 404 })
    }

    // Get the offer
    const offer = await prisma.offer.findUnique({
      where: { id: params.id },
      include: {
        hostProfile: {
          include: { user: true },
        },
        property: true,
      },
    })

    if (!offer) {
      return NextResponse.json({ error: 'Offer not found' }, { status: 404 })
    }

    // Verify this offer is for the current creator
    if (offer.creatorProfileId !== creatorProfile.id) {
      return NextResponse.json({ error: 'This offer is not for you' }, { status: 403 })
    }

    // Verify offer is actionable (pending or countered)
    if (!['pending', 'countered'].includes(offer.status)) {
      return NextResponse.json({ error: 'This offer has already been responded to' }, { status: 400 })
    }

    // Handle DECLINE
    if (action === 'decline') {
      // Record status change with history
      try {
        await recordOfferStatusChange(
          params.id,
          'pending',
          'declined',
          'creator',
          'Creator declined the offer'
        )
      } catch (statusError) {
        console.error('[Offer Decline] Failed to record status change:', statusError)
        // Fall back to simple update
        await prisma.offer.update({
          where: { id: params.id },
          data: {
            status: 'declined',
            respondedAt: new Date(),
          },
        })
      }

      // Update respondedAt separately if recordOfferStatusChange succeeded
      await prisma.offer.update({
        where: { id: params.id },
        data: { respondedAt: new Date() },
      }).catch(() => {}) // Ignore if already updated

      // Log audit event
      try {
        await logOfferEvent(
          AUDIT_ACTIONS.OFFER_STATUS_CHANGED,
          params.id,
          'user',
          creatorProfile.id,
          { fromStatus: 'pending', toStatus: 'declined' }
        )
      } catch (auditError) {
        console.error('[Offer Decline] Failed to log audit event:', auditError)
      }

      // Log analytics event
      try {
        await logOfferResponded(creatorProfile.id, params.id, 'declined', offer.hostProfileId)
      } catch (analyticsError) {
        console.error('[Offer Decline] Failed to log analytics event:', analyticsError)
      }

      // Mark first offer responded for lifecycle tracking
      try {
        await markFirstOfferResponded(creatorProfile.id)
      } catch (lifecycleError) {
        console.error('[Offer Decline] Failed to mark first offer responded:', lifecycleError)
      }

      // Send email to host
      const hostEmail = offer.hostProfile.user?.email || offer.hostProfile.contactEmail
      if (hostEmail) {
        const emailData = offerDeclinedEmail({
          hostName: offer.hostProfile.displayName,
          creatorName: creatorProfile.displayName,
          creatorHandle: creatorProfile.handle,
          propertyTitle: offer.property?.title || 'your property',
        })

        sendEmail({
          to: hostEmail,
          ...emailData,
        }).catch(err => console.error('[Offer Decline] Email error:', err))
      }

      return NextResponse.json({
        success: true,
        message: 'Offer declined.',
      })
    }

    // Handle COUNTER
    if (action === 'counter') {
      if (!counterCashCents || counterCashCents <= 0) {
        return NextResponse.json({ error: 'Counter amount required' }, { status: 400 })
      }

      // Check negotiation rounds - warn after 3 rounds, block after 5
      const currentRound = offer.negotiationRound || 1
      const newRound = currentRound + 1
      
      if (newRound > 5) {
        return NextResponse.json({ 
          error: 'Maximum negotiation rounds reached (5). Please accept or decline this offer.' 
        }, { status: 400 })
      }

      // Record status change with history
      try {
        await recordOfferStatusChange(
          params.id,
          offer.status,
          'countered',
          'creator',
          `Counter offer: ${(counterCashCents / 100).toFixed(2)}${counterMessage ? ` - ${counterMessage}` : ''}`
        )
      } catch (statusError) {
        console.error('[Offer Counter] Failed to record status change:', statusError)
      }

      // Update the offer with counter details
      await prisma.offer.update({
        where: { id: params.id },
        data: {
          counterCashCents,
          counterMessage,
          respondedAt: new Date(),
          negotiationRound: newRound,
          lastCounterBy: 'creator',
        },
      })

      // Log audit event
      try {
        await logOfferEvent(
          AUDIT_ACTIONS.OFFER_STATUS_CHANGED,
          params.id,
          'user',
          creatorProfile.id,
          { 
            fromStatus: offer.status, 
            toStatus: 'countered',
            counterCashCents,
            negotiationRound: newRound,
          }
        )
      } catch (auditError) {
        console.error('[Offer Counter] Failed to log audit event:', auditError)
      }

      // Log analytics event
      try {
        await logOfferResponded(creatorProfile.id, params.id, 'countered', offer.hostProfileId)
      } catch (analyticsError) {
        console.error('[Offer Counter] Failed to log analytics event:', analyticsError)
      }

      // Mark first offer responded for lifecycle tracking
      try {
        await markFirstOfferResponded(creatorProfile.id)
      } catch (lifecycleError) {
        console.error('[Offer Counter] Failed to mark first offer responded:', lifecycleError)
      }

      // Send email to host about counter offer
      const hostEmail = offer.hostProfile.user?.email || offer.hostProfile.contactEmail
      if (hostEmail) {
        const emailData = offerCounteredEmail({
          hostName: offer.hostProfile.displayName,
          creatorName: creatorProfile.displayName,
          creatorHandle: creatorProfile.handle,
          propertyTitle: offer.property?.title || 'your property',
          originalAmount: offer.cashCents,
          counterAmount: counterCashCents,
          counterMessage,
          offerId: offer.id,
        })

        sendEmail({
          to: hostEmail,
          ...emailData,
        }).catch(err => console.error('[Offer Counter] Email error:', err))
      }

      // Include warning if approaching limit
      const warning = newRound >= 4 
        ? `Note: This is negotiation round ${newRound} of 5 maximum. Consider finalizing terms soon.`
        : null

      return NextResponse.json({
        success: true,
        message: 'Counter offer sent to host.',
        negotiationRound: newRound,
        warning,
      })
    }

    // Handle ACCEPT
    if (action === 'accept') {
      // Check if creator has Stripe Connect set up (required for paid offers)
      if (offer.cashCents > 0 || offer.trafficBonusEnabled) {
        if (!creatorProfile.stripeAccountId || !creatorProfile.stripeOnboardingComplete) {
          return NextResponse.json({ 
            error: 'Please set up your payment account before accepting paid offers.',
            code: 'STRIPE_NOT_CONNECTED',
          }, { status: 400 })
        }
      }

      // Use property from offer, or fall back to finding one
      let property = offer.property
      if (!property) {
        property = await prisma.property.findFirst({
          where: { hostProfileId: offer.hostProfileId },
        })
      }

      if (!property) {
        return NextResponse.json({ error: 'Host has no property configured' }, { status: 400 })
      }

      // Generate tracking token
      const affiliateToken = nanoid(12)

      // Create collaboration
      const collaboration = await prisma.collaboration.create({
        data: {
          hostId: offer.hostProfileId,
          creatorId: creatorProfile.id,
          propertyId: property.id,
          offerId: offer.id,
          status: 'pending-agreement',
          affiliateToken,
          contentDeadline: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days
        },
      })

      // Generate agreement text
      const agreementText = generateAgreementText({
        hostName: offer.hostProfile.displayName,
        creatorName: creatorProfile.displayName,
        propertyTitle: property.title || 'Property',
        dealType: offer.offerType,
        cashCents: offer.cashCents,
        stayNights: offer.stayNights,
        deliverables: offer.deliverables,
      })

      // Create agreement
      await prisma.collaborationAgreement.create({
        data: {
          collaborationId: collaboration.id,
          version: '1.0',
          agreementText,
          // Parties
          hostName: offer.hostProfile.displayName,
          hostEmail: offer.hostProfile.user?.email || offer.hostProfile.contactEmail || '',
          creatorName: creatorProfile.displayName,
          creatorHandle: creatorProfile.handle,
          creatorEmail: creatorProfile.user.email || '',
          // Property
          propertyTitle: property.title || 'Property',
          propertyLocation: property.cityRegion,
          propertyUrl: property.airbnbUrl,
          // Deal terms
          dealType: offer.offerType,
          cashAmount: offer.cashCents,
          stayIncluded: !!offer.stayNights,
          stayNights: offer.stayNights,
          // Bonus terms
          bonusEnabled: offer.trafficBonusEnabled,
          bonusAmount: offer.trafficBonusCents,
          bonusThreshold: offer.trafficBonusThreshold,
          // Deliverables
          deliverables: offer.deliverables,
          contentDeadline: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
        },
      })

      // Record status change with history
      try {
        await recordOfferStatusChange(
          params.id,
          offer.status,
          'accepted',
          'creator',
          'Creator accepted the offer'
        )
      } catch (statusError) {
        console.error('[Offer Accept] Failed to record status change:', statusError)
        // Fall back to simple update
        await prisma.offer.update({
          where: { id: params.id },
          data: { status: 'accepted' },
        })
      }

      // Update respondedAt separately
      await prisma.offer.update({
        where: { id: params.id },
        data: { respondedAt: new Date() },
      }).catch(() => {})

      // Log audit event
      try {
        await logOfferEvent(
          AUDIT_ACTIONS.OFFER_STATUS_CHANGED,
          params.id,
          'user',
          creatorProfile.id,
          { 
            fromStatus: offer.status, 
            toStatus: 'accepted',
            collaborationId: collaboration.id,
          }
        )
      } catch (auditError) {
        console.error('[Offer Accept] Failed to log audit event:', auditError)
      }

      // Log analytics event
      try {
        await logOfferResponded(creatorProfile.id, params.id, 'accepted', offer.hostProfileId)
      } catch (analyticsError) {
        console.error('[Offer Accept] Failed to log analytics event:', analyticsError)
      }

      // Mark first offer responded for lifecycle tracking
      try {
        await markFirstOfferResponded(creatorProfile.id)
      } catch (lifecycleError) {
        console.error('[Offer Accept] Failed to mark first offer responded:', lifecycleError)
      }

      // Send email to host
      const hostEmail = offer.hostProfile.user?.email || offer.hostProfile.contactEmail
      if (hostEmail) {
        const emailData = offerAcceptedEmail({
          hostName: offer.hostProfile.displayName,
          creatorName: creatorProfile.displayName,
          creatorHandle: creatorProfile.handle,
          propertyTitle: property.title || 'Property',
          collaborationId: collaboration.id,
        })

        sendEmail({
          to: hostEmail,
          ...emailData,
        }).catch(err => console.error('[Offer Accept] Email error:', err))
      }

      return NextResponse.json({
        success: true,
        message: 'Offer accepted! Please sign the agreement to activate.',
        collaboration: {
          id: collaboration.id,
          affiliateToken,
        },
      })
    }

    return NextResponse.json({ error: 'Invalid action' }, { status: 400 })
  } catch (error) {
    console.error('[Offer Response API] Error:', error)
    return NextResponse.json({ error: 'Failed to respond to offer' }, { status: 500 })
  }
}
